<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[euler002题]]></title>
    <url>%2F2018%2F01%2F25%2Feuler002%E9%A2%98%2F</url>
    <content type="text"><![CDATA[题目： Each new term in the Fibonacci sequence is generated by adding the previous two terms. By starting with 1 and 2, the first 10 terms will be: 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, … By considering the terms in the Fibonacci sequence whose values do not exceed four million, find the sum of the even-valued terms. 分析题目要的结果是找到斐波那契数列中不超过四百万的为偶数的项并求和。 首先就是要构造一个求第n项斐波那契数列的方法，这里我用递归实现的： 12345def fibonacci(n): if n==1 or n==0: return 1 else: return fibonacci(n-1)+fibonacci(n-2) 下面就是找出是偶数的项并且求和了，这里也有两种解法，第一种就是写个死循环，当斐波那契数列的项超过四百万就退出，判断能被2整除就加和，这种方法我没有实现=-=，因为比较耗时，懒得等。 第二种方法就是要观察数列的规律，为偶数的项的产生有没有规律。当然。。我都这么说了显然是有了。 1,1, 2, 3, 5, 8, 13, 21, 34, 55, 89,144.. 我们发现这些为偶数的项每隔两项就会出现（奇数偶数的性质决定的），这样我们循环的时候可以把步长加大，更迅速的求出结果。 123456789n=2sum=0while 1: res=fibonacci(n) if fibonacci(n)&gt;4000000: break sum = sum+res n+=3print sum -EOF-]]></content>
      <categories>
        <category>欧拉工程</category>
      </categories>
      <tags>
        <tag>euler</tag>
        <tag>math</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring源码之启动与初始化]]></title>
    <url>%2F2018%2F01%2F23%2FSpring%E6%BA%90%E7%A0%81%E4%B9%8BBean%E5%8A%A0%E8%BD%BD%2F</url>
    <content type="text"><![CDATA[此文源码基于Spring 4.3.2.RELEASE版本 转型Java开发快满一年了，工作中经常使用Spring，并享受着Spring带来的便利，未曾研究过他是如何工作的，临近年关，闲散时间慢慢多了，遂借鉴网上的资料以及自己的愚见啃一啃Spring的部分源码。 本文主要介绍Spring启动与初始化过程。 关于web.xml 首先看web.xml里面的配置。 12345678910&lt;!--上下文均省略--&gt; &lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt; classpath:/META-INF/spring/app-bootstrap.xml &lt;/param-value&gt; &lt;/context-param&gt; &lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt; &lt;/listener&gt; Spring是通过web.xml配置的org.springframework.web.context.ContextLoaderListener来初始化IoC容器的。ContextLoaderListener继承了ContextLoader，并且实现ServletContextListener接口。当Server容器（一般指tomcat）启动时，会收到事件初始化。web.xml文件中&lt;context-params&gt; 节点包含上下文类型(contextClass)和上下文配置路径(contextConfigLocation)两种配置参数。 其中，contextClass设置客户自定义的WebApplicationContext类型。当contextClass未找到时创建默认的XmlWebApplicationContext。 contextConfigLocation 用于设置applicatioContext*.xml文件的路径。不设置时默认为&quot;/WEB-INF/applicationContext.xml&quot; (详情见XmlWebApplicationContext 类)。多个上下文配置文件可用逗号或者空格分开。initWebApplicationContext方法 ContextLoaderListener 的构造方法 &lt;context-params&gt; 中的 contextClass 和 contextConfigLocation 这两个配置属性,调用初始化方法： contextInitialized() 创建Web应用程序上下文。下文将首先从应用上下文的初始化过程进行探究。 1234@Overridepublic void contextInitialized(ServletContextEvent event) &#123; initWebApplicationContext(event.getServletContext());&#125; initWebApplicationContext在ContextLoader类里面，代码贴到下面：12345678910111213141516171819202122232425262728293031323334353637383940public WebApplicationContext initWebApplicationContext(ServletContext servletContext) &#123; ... try &#123; // Store context in local instance variable, to guarantee that // it is available on ServletContext shutdown. if (this.context == null) &#123; this.context = createWebApplicationContext(servletContext); &#125; if (this.context instanceof ConfigurableWebApplicationContext) &#123; ConfigurableWebApplicationContext cwac = (ConfigurableWebApplicationContext) this.context; if (!cwac.isActive()) &#123; // The context has not yet been refreshed -&gt; provide services such as // setting the parent context, setting the application context id, etc if (cwac.getParent() == null) &#123; // The context instance was injected without an explicit parent -&gt; // determine parent for root web application context, if any. ApplicationContext parent = loadParentContext(servletContext); cwac.setParent(parent); &#125; configureAndRefreshWebApplicationContext(cwac, servletContext); &#125; &#125; servletContext.setAttribute(WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE, this.context); ClassLoader ccl = Thread.currentThread().getContextClassLoader(); if (ccl == ContextLoader.class.getClassLoader()) &#123; currentContext = this.context; &#125; else if (ccl != null) &#123; currentContextPerThread.put(ccl, this.context); &#125; if (logger.isDebugEnabled()) &#123; logger.debug("Published root WebApplicationContext as ServletContext attribute with name [" + WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE + "]"); &#125; if (logger.isInfoEnabled()) &#123; long elapsedTime = System.currentTimeMillis() - startTime; logger.info("Root WebApplicationContext: initialization completed in " + elapsedTime + " ms"); &#125; return this.context; &#125; ...&#125; 可以看到主要的逻辑都在try{}里。如果上下文为空的时候，则调用createWebApplicationContext方法创建上下文。 createWebApplicationContext方法123456789protected WebApplicationContext createWebApplicationContext(ServletContext sc) &#123; Class&lt;?&gt; contextClass = determineContextClass(sc); if (!ConfigurableWebApplicationContext.class.isAssignableFrom(contextClass)) &#123; throw new ApplicationContextException("Custom context class [" + contextClass.getName() + "] is not of type [" + ConfigurableWebApplicationContext.class.getName() + "]"); &#125; //根据类来返回实例 return (ConfigurableWebApplicationContext) BeanUtils.instantiateClass(contextClass);&#125; 其中determineContextClass就是来寻找WebApplicationContext接口的类： 123456789101112131415161718protected Class&lt;?&gt; determineContextClass(ServletContext servletContext) &#123; /**public static final String CONTEXT_CLASS_PARAM = "contextClass";**/ String contextClassName = servletContext.getInitParameter(CONTEXT_CLASS_PARAM); if (contextClassName != null) &#123; try &#123; return ClassUtils.forName(contextClassName, ClassUtils.getDefaultClassLoader()); &#125; ... &#125; else &#123; //关键代码 contextClassName = defaultStrategies.getProperty(WebApplicationContext.class.getName()); try &#123; return ClassUtils.forName(contextClassName, ContextLoader.class.getClassLoader()); &#125; ... &#125; &#125; 上述代码表明，如果开发者在web.xml中配置了一个参数名为contextClass，值为WebApplicationContext 接口实现类，那么getInitParameter就会返回这个配置的实现类；如果没有配置，defaultStrategies.getProperty()就返回默认的实现类XmlWebApplicationContext。默认实现类在ContextLoader静态代码段内，在类加载的时候就会执行。ContextLoader同路径下的可以找到这个配置文件 ContextLoader.properties 。 1org.springframework.web.context.WebApplicationContext=org.springframework.web.context.support.XmlWebApplicationContext XmlWebApplicationContext是WebApplicationContext这个接口的最终实现类，也是Spring启动时默认使用的类。 创建上下文的类型必须是ConfigurableWebApplicationContext的实例。 configureAndRefreshWebApplicationContext方法创建完WebApplicationContext之后就会调用configureAndRefreshWebApplicationContext() 来进行配置。 通常是对XmlWebApplicationContext进行初始化。 1234567891011121314protected void configureAndRefreshWebApplicationContext(ConfigurableWebApplicationContext wac, ServletContext sc) &#123; ... //在ServletContext中获取contextConfigLocation的值并咋找配置文件地址 wac.setServletContext(sc); //public static final String CONFIG_LOCATION_PARAM = "contextConfigLocation"; String configLocationParam = sc.getInitParameter(CONFIG_LOCATION_PARAM); if (configLocationParam != null) &#123; wac.setConfigLocation(configLocationParam); &#125; ... customizeContext(sc, wac); //刷新XmlWebApplicationContext wac.refresh();&#125; 拿到配置信息，就到了wac.refresh()方法了，此方法具体实现在AbstractApplicationContext类中： 12345678910111213141516171819202122232425262728293031public void refresh() throws BeansException, IllegalStateException &#123; synchronized (this.startupShutdownMonitor) &#123; // 容器预先准备，记录容器启动时间和标记 prepareRefresh(); // 创建Bean工厂，实现BeanDefinition的装载 ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory(); // 配置Bean工厂的上下文信息，如类装载器等 prepareBeanFactory(beanFactory); try &#123; // 在BeanDefinition被装载后，提供一个修改BeanFactory的入口 postProcessBeanFactory(beanFactory); // 在bean初始化之前，提供对BeanDefinition修改入口，PropertyPlaceholderConfigurer在这里被调用 invokeBeanFactoryPostProcessors(beanFactory); // 注册各种BeanPostProcessors，用于在bean被初始化时进行拦截，进行额外初始化操作 registerBeanPostProcessors(beanFactory); // /初始化MessageSource initMessageSource(); // 初始化上下文事件广播 initApplicationEventMulticaster(); // 模板方法 onRefresh(); // 注册监听器 registerListeners(); // 初始化所有未初始化的非懒加载的单例Bean finishBeanFactoryInitialization(beanFactory); // 发布时间通知 finishRefresh(); &#125; ... &#125;&#125; 这里就完成了IOC容器的初始化步骤了。 IOC初始化后IOC容器初始化之后可以看到还有一行代码： 1servletContext.setAttribute(WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE, this.context); 可以看到，初始化的context被存放在servletContext中，实际存放在了一个ConcurrentMap中。 到这里Spring的启动与初始化就结束了，整个Spring容器被放置在ServletContext这样一个类似于Map的结构中。ServletContext 从字面上理解也是Servlet的容器，被 Servlet 程序间接用来与外层 Web 容器通信，例如写日志，转发请求等。每一个 Web 应用程序含有一个Context ，被Web 应用内的各个程序共享。因为Context 可以用来保存资源并且共享，所以ServletContext 的常用场景是Web级应用缓存—- 把不经常更改的内容读入内存，所以服务器响应请求的时候就不需要进行慢速的磁盘I/O 了。 -EOF- 参考引用 漫谈Spring的启动与初始化（二） 看看Spring的源码（一）——Bean加载过程]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[euler001题]]></title>
    <url>%2F2018%2F01%2F20%2Feuler001%E9%A2%98%2F</url>
    <content type="text"><![CDATA[题目：If we list all the natural numbers below 10 that are multiples of 3 or 5, we get 3, 5, 6 and 9. The sum of these multiples is 23.Find the sum of all the multiples of 3 or 5 below 1000. 分析解法一题目很简单，将1000以内被3或5整除的数字加起来，所以最简单的解法就是暴力遍历：1print sum([x for x in range(1,1000) if x%3==0 or x%5==0]) 解法二当然，这个解法很简单，但不优雅，所以再用数学思维梳理一下刚才的题目，看看能不能总结出规律123456#3的倍数相加3+6+9+...+999=3*(1+2+3+...+333)#5的倍数相加5+10+15+...+995=5*(1+2+3+...+195)#1-n的累加公式1+2+3+...+n=(n*(n+1))/2 这样一写就简明多了，当让不要忘了在这两个数列里有3和5的公倍数被计算了两次，千万不要忘记减掉 1234def sumdivisibleby(n): p = 999/n return n*(p*(p+1))/2print sumdivisibleby(3)+sumdivisibleby(5)-sumdivisibleby(15) -EOF-]]></content>
      <categories>
        <category>欧拉工程</category>
      </categories>
      <tags>
        <tag>euler</tag>
        <tag>math</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F01%2F20%2FHello-World%2F</url>
    <content type="text"><![CDATA[12345#include&lt;stdio.h&gt;public void main()&#123; printf("Hello World");&#125; -EOF-]]></content>
      <tags>
        <tag>瞎写</tag>
      </tags>
  </entry>
</search>
