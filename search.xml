<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[投资中不简单的事-读书笔记]]></title>
    <url>%2F2018%2F02%2F01%2F%E6%8A%95%E8%B5%84%E4%B8%AD%E4%B8%8D%E7%AE%80%E5%8D%95%E7%9A%84%E4%BA%8B-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[思想篇 投资人说 邱国鹭：我们做价值投资，把时间拉长，总是赚两方面的钱：一方面赚的是企业被低估的钱，这个是市场过度悲观、市场情绪化定价所带来的机会；另一方面赚的是企业成长的钱，是管理团队不断为股东创造的价值、创造的新收益。 01 回归投资的本质，做时间的朋友投资本质上还是希望买到低估的东西，买到将来能够超过大家预期而成长的东西。]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>读书笔记</tag>
        <tag>投资理财</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Cron表达式]]></title>
    <url>%2F2018%2F02%2F01%2FCron%E8%A1%A8%E8%BE%BE%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[在使用TBSchedule调度任务时发现任务调度时间使用的是Cron表达式，遂将Cron表达式的用法整理以备他用。 1. 表达式格式Cron表达式是一个字符串，字符串以5或6个空格隔开，分为6或7个域，每一个域代表一个含义，Cron有如下两种语法格式： Seconds Minutes Hours DayofMonth Month DayofWeek Year或 Seconds Minutes Hours DayofMonth Month DayofWeek 2. 表达式范围及特殊字符解释 字段 允许值 允许的特殊字符 秒 0-59 , - * / 分 0-59 , - * / 时 0-23 , - * / 日期 1-31 , - * ? / L W C 月份 1-12 或者 JAN-DEC , - * / 星期 1-7 或者 SUN-SAT , - * ? / L C # 年 留空, 1970-2099 , - * / 123456789* 代表任何值。？只在日期域和星期域中使用。用来指代不明确的值。月份中的日期和星期中的日期有互斥时应该通过设置一个问号来表明不想设置的一个域。- 用来指代一个范围。, 用来列举几个值/ 用来指定增量，每一个周期执行一次L 如果&#123;日&#125;占位符如果是"L"，即意味着当月的最后一天触发;如果&#123;周&#125;占位符如果是"L"，即意味着星期的的最后一天触发，即星期六触发，L= 7或者 L = SAT，因此，"5L"意味着一个月的最后一个星期四触发 W 意味着在本月内离当天最近的工作日触发，所谓最近工作日，即当天到工作日的前后最短距离，如果当天即为工作日，则距离为0；所谓本月内的说法，就是不能跨月取到最近工作日，即使前/后月份的最后一天/第一天确实满足最近工作日；因此，"LW"则意味着本月的最后一个工作日触发，"W"强烈依赖&#123;月&#125; # 只允许在星期域中出现。指代本月第几星期的第几天。C 允许在日期域和星期域出现。这个字符依靠一个指定的“日历”。也就是说这个表达式的值依赖于相关的“日历”的计算结果，如果没有 “日历”关联，则等价于所有包含的“日历”。 3. 常见实例12345678910111213141516171819202122232425262728293031323334353637"0 0 10,14,16 * * ?" 每天上午10点，下午2点，4点 "0 0/30 9-17 * * ?" 朝九晚五工作时间内每半小时 "0 0 12 ? * WED" 表示每个星期三中午12点 "0 0 12 * * ?" 每天中午12点触发 "0 15 10 ? * *" 每天上午10:15触发 "0 15 10 * * ?" 每天上午10:15触发 "0 15 10 * * ? *" 每天上午10:15触发 "0 15 10 * * ? 2005" 2005年的每天上午10:15触发 "0 * 14 * * ?" 在每天下午2点到下午2:59期间的每1分钟触发 "0 0/5 14 * * ?" 在每天下午2点到下午2:55期间的每5分钟触发 "0 0/5 14,18 * * ?" 在每天下午2点到2:55期间和下午6点到6:55期间的每5分钟触发 "0 0-5 14 * * ?" 在每天下午2点到下午2:05期间的每1分钟触发 "0 10,44 14 ? 3 WED" 每年三月的星期三的下午2:10和2:44触发 "0 15 10 ? * MON-FRI" 周一至周五的上午10:15触发 "0 15 10 15 * ?" 每月15日上午10:15触发 "0 15 10 L * ?" 每月最后一日的上午10:15触发 "0 15 10 ? * 6L" 每月的最后一个星期五上午10:15触发 "0 15 10 ? * 6L 2002-2005" 2002年至2005年的每月的最后一个星期五上午10:15触发 "0 15 10 ? * 6#3" 每月的第三个星期五上午10:15触发 "30 * * * * ?" 每半分钟触发任务 "30 10 * * * ?" 每小时的10分30秒触发任务 "30 10 1 * * ?" 每天1点10分30秒触发任务 "30 10 1 20 * ?" 每月20号1点10分30秒触发任务 "30 10 1 20 10 ? *" 每年10月20号1点10分30秒触发任务 "30 10 1 20 10 ? 2011" 2011年10月20号1点10分30秒触发任务 "30 10 1 ? 10 * 2011" 2011年10月每天1点10分30秒触发任务 "30 10 1 ? 10 SUN 2011" 2011年10月每周日1点10分30秒触发任务 "15,30,45 * * * * ?" 每15秒，30秒，45秒时触发任务 "15-45 * * * * ?" 15到45秒内，每秒都触发任务 "15/5 * * * * ?" 每分钟的每15秒开始触发，每隔5秒触发一次 "15-30/5 * * * * ?" 每分钟的15秒到30秒之间开始触发，每隔5秒触发一次 "0 0/3 * * * ?" 每小时的第0分0秒开始，每三分钟触发一次 "0 15 10 ? * MON-FRI" 星期一到星期五的10点15分0秒触发任务 "0 15 10 L * ?" 每个月最后一天的10点15分0秒触发任务 "0 15 10 LW * ?" 每个月最后一个工作日的10点15分0秒触发任务 "0 15 10 ? * 5L" 每个月最后一个星期四的10点15分0秒触发任务 "0 15 10 ? * 5#3" 每个月第三周的星期四的10点15分0秒触发任务 "0 0 0 * * ?" 每天晚上12点触发任务 -EOF- 参考引用： Spring Task 中cron表达式整理记录 JAVA quartz cron 表达式详解 日期表达式]]></content>
      <categories>
        <category>工具集</category>
      </categories>
      <tags>
        <tag>Corn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[投资中最简单的事-读书笔记]]></title>
    <url>%2F2018%2F01%2F31%2F%E6%8A%95%E8%B5%84%E4%B8%AD%E6%9C%80%E7%AE%80%E5%8D%95%E7%9A%84%E4%BA%8B-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[投资理念 1.以实业的眼光做投资 关键词：护城河,成长VS门槛 案例: 白色家电00-05年成长迅速但利润不佳，06-10行业增速减缓但利润大增。拐点在05年的行业大洗牌，行业格局从野蛮生长的无序竞争转变为有门槛的有序竞争。 优秀基金经理： 把客户的前当自己的钱来珍惜 把二级市场的股票投资当做一级市场的实业投资来分析 行业集中度持续提高的行业易出长期牛股。 好公司的两个标准： 他做的事别人做不了 做的事情自己可以重复做 互联网的本质是“人生人”，优势在于能以极低成本服务无数客户，规模效应体现在人多，典型的散户经济。 互联网“人生人”：1.网络效应；2.人多提升用户体验 投资制造业时更应关注工程机械、核心汽配、白色家电这样的寡头行业。分析技术变化快的行业时不必看市场占有率，而要看是否适应最新的杀手级应用的潮流。 做投资要研究的就是这些不以人的意志为转移的规律，而不是整天去猜测市场的情绪变化。 2.人弃我取，逆向投资的关键 关键词：新兴行业看需求，传统行业看供给,行业集中度,未得到、已失去与正拥有 一只下跌的股票是否值得逆向投资的关键在于以下三点： 看估值是否够低、是否已经过度反映了可能的坏消息。 看遭遇的问题是否是短期问题、是否是可解决的问题。 看股价暴跌本身是否会导致公司的基本面进一步恶化，即是否有索罗斯所说的反身性。 不是每个行业都适合做逆向投资： 有无替代品 是个股问题还是行业问题 是主动添加违规成分还是“被动中枪” 该问题是否容易解决 涉事企业是否有扎实的根基 是否有突出的受害者个例 最一直的时候就是最危险的时候。 作为投资者，在当时的那种环境之下，我们只能牢记管子所说的“不处不可久，不行不可复”，不去“击鼓传花”，不接最后一棒，把选股范围基本限制在低估值的大盘蓝筹里。 逆向投资并非一味与市场作对，因为市场在大多数时候是对的。但有的时候市场也可以错得很离谱，此时就不必在意市场的主流观点了。 买早了还得熬得住，这是逆向投资者的必备素质。 每年年初和年中时汇总所有基金公司的季报行业配置。对大家都追捧的热门行业，我就谨慎一点；对大家都嫌弃的冷门行业，我就试着乐观一点。 3.便宜是硬道理 关键词：军阀割据，没有门槛的高增长，政策 有销售半径的行业（如啤酒和水泥），重要的不是全国市场占有率，而是区域市场集中度。 投资中影响股价涨跌的因素是无穷无尽的，但是最重要的其实只有两点，一个是估值，一个是流动性。 价格的本质是一种货币现象。 买的时候足够便宜，就不用担心做傻瓜。 有门槛、有积累、有定价权的那种行业。 投资方法4.投资的三个基本问题 关键词：医改，医药股 第一个是估值的问题，第二个是公司品质的问题，第三个是买卖时机的问题 世界上每个成功的投资家都是长期坚持一种方法的。 在好行业中挑选好公司，然后等待好价格时买入。 投资分析的基本工具： 波特五力分析 重点搞清三个问题：公司对上下游的议价权、与竞争对手的比较优势、行业对潜在进入者的门槛。 杜邦分析 弄清公司过去５年究竟是靠什么模式赚钱的（高利润、高周转还是高杠杆），然后看公司战略规划、团队背景和管理执行力等是否与其商业模式一致。 估值分析 通过同业横比和历史纵比，加上市值与未来成长空间比，在显著低估时买入。 马和骑师，选马比选骑师重要。特别是对大公司而言，这是一匹怎样的马比这是一个怎样的骑师更重要。特别是在中国这种环境中，你很难判断骑师的好坏。 品质判断： 是不是一个好行业 公司的品质好坏，关键是看能不能具有定价权。 躲避政府扶持 差异化竞争 差异化的第一个标志是品牌。 差异化的第二个标志是有回头客，即用户黏度高。 差异化的第三个标志是单价不要太高。 差异化的第四个标志是转换成本。差异化的关键在于能不能提价，提价之后是不是不影响销售。 差异化的第五个标志是服务网络。产品的销售半径小，也是一个优势。 差异化的第六个标志是先发优势。 对行业格局的分析和对公司核心竞争力的理解是“道”，财务分析只是“术”，但是后者对前者起着验证和把关的作用。 要认识一个行业，不妨做一道填空题：得 者得天下，用一个词来概括这个行业竞争的是什么。例如，基金业是得人才者得天下，高端消费品是得品牌者得天下，低端消费品是得渠道者得天下，无差异中间品是得成本者得天下，制造业是得规模者得天下，大宗品是得资源者得天下。 历史上的股市见底信号1.市场估值在历史低位；2.M1见底回升；3.降存准或降息；4.成交量极度萎缩；5.社保汇金入市；6.大股东和高管增持；7.机构大幅超配非周期类股票；8.强周期股在跌时抗跌，涨时领涨；9.机构仓位在历史低点；10.新股停发或降印花税。 5.宁数月亮，不数星星 关键词：周期性成长股，港股，季报 市场低迷时，周期性成长股是最值得关注的，因为它们的估值会因其周期性而被恐慌性杀跌，但业绩增长却能因其成长性而跨越周期。 6.经验就像旧衣服 关键词：零售业，电子股 投资风险7.价值陷阱与成长陷阱 关键词：政府扶持的产业，政府补贴的产业，选马，还是选骑师 一个简单的原则是：对小公司来讲，骑师更重要一些；对大公司来讲，“马”本身的质量更起决定性作用。 金玉之堂，莫之能守。 一个蠢办法有效，那它就不蠢。 不为不可成，不求不可得，不处不可久，不行不可复。 8.真假风险与安全边际 关键词：品牌VS渠道，看历届标王有感 砸钱只能砸出知名度，砸不出美誉度。品牌的形成需要时间积累，所谓三代出一贵族。 在互联网时代，品牌的优势比渠道的优势更重要。因为随着网购的物流配送体系的完善，渠道的优势会渐渐被淡化；而随着媒体受众的碎片化，塑造一个品牌的成本已大幅上升。 两种风险 一是股价短期波动的风险，二是本金永久性丧失的风险。股价下跌的过程中，第一种风险在加大，第二种风险在减小。 安全边际： 东方不亮西方亮，给点阳光就灿烂 估值低到足以反应大多数可能的坏情况 低估值本身反应的就是对未来的低预期。只要估值低到足以反应大多数可能的坏情况，未来低于预期的可能性就很小了。 有“冗余设计”，有“备用系统”来限制下跌空间 价值易估，不具反身性，可越跌越买 凡事要留有余地，做投资也一样，因为市场总是天有不测风云。 卖股票的三个理由：基本面恶化；价格达到目标价；有更好的其他投资。 卖出的原因就是：公司没有想象的好；不再便宜；还有其他更好更便宜的公司。 忘掉你的成本，是成功投资的第一步。 9.价值投资的局限性 关键词：骑马找马，一月风向标 在A股过去的21年中，有17年里股市全年走势与一月份的走势在涨跌方向上是一致的，准确率高达81%，胜过所有的策略分析师和经济学家。 价值投资就是当股票价格低于公司内在价值时买入，当股票价格高于内在价值时卖出。 价值投资的第一个基本条件：所买的公司的内在价值应该是相对容易确定的。 价值投资的第二个基本条件：所投资的公司的内在价值应该相对独立于股票价格。 索罗斯一再强调的反身性本质上就是价格对价值的这种反作用力。在一定条件下，这种反身性会自我加强，导致恶性循环，因而股价的表现会大大出乎价值投资者的意料。 价值投资的第三个基本条件：要在合适的市场阶段采用。 价值投资的第四个基本条件：选取合适的投资期限。 入行第一年就遇上公司业绩落后，对一个职业投资人而言其实是件好事：可以学会如何在逆境中坚持自己的投资理念，学会在压力下保持头脑的冷静，学会在谷底要有仰望星空的勇气。 在泡沫顶峰，大家都在说“这次不同了”，他却坚定地说“这也会过去”。他经常鼓励我看旧书、旧报告、旧杂志。历史读多了，对许多事情就见怪不怪了。 芒格对年轻人择业有三个建议：别兜售你不相信的东西，别为你不敬佩的人工作，别和你不喜欢的人共事。 逻辑性强的策略报告一般没用，因为市场经常不讲逻辑。 投资策略我的老师是历史，我觉得没有什么新鲜事在发生，所有发生了的或者将要发生的，已经在过去发生过了。 10.四种周期、三种杠杆，行业轮动使劲的把握 关键词：未来中国的行业趋势，有品牌优势的消费股，国家的比较优势 对于大资金来说，行业配置对总体投资收益的影响常常比精选个股更为重要。 四种周期 政策周期 市场周期（估值周期） 经济周期 盈利周期 熊末牛初，股市见底时这四种周期见底的先后次序是： 政策周期领先于市场周期。在货币政策和财政政策放松后，市场往往在资金面和政策面的推动下进行重新估值。 市场周期领先于经济周期。美国历史上几乎每次经济衰退，股市都先于经济走出谷底（2001年的衰退除外）。 经济周期领先于盈利周期，换句话说，宏观基本面领先于微观基本面。过去70年中，美国的经济衰退从未长于16个月，但是盈利下降经常持续2~3年甚至更长。 熊末牛初，判断市场走势，资金面和政策面是领先指标，基本面是滞后指标。熊市见底时，微观基本面往往很不理想，不能以此作为低仓的依据。如果一定要等到基本面改善才加仓，往往已经晚了。 三种杠杆 财务杠杆：对利率的弹性 运营杠杆：对经济的弹性 估值杠杆：对剩余流动性的弹性 第一阶段，熊市见底时，经济仍然低迷，但是货币政策宽松，利率不断降低，常常是财务杠杆高的企业先见底。此时，某些高负债的竞争对手已经或者正在出局（破产或者被收购），剩余的企业的市场份额和定价权都得到提高。 第二阶段，经济开始复苏，利率稳定于低位，此时的板块轮动常常是运营杠杆高的行业领涨，因为这类企业只需销售收入的小幅反弹就能带来利润的大幅提升，基本面的改善比较显著。 第三阶段，经济繁荣，利润快速增长，但是股票价格涨幅更大，估值扩张替代基本面改善成为推动股价的主动力，此时估值杠杆高，有想象空间的股票往往能够领涨。 第四阶段，熊牛替换时，不要太在意盈利增长的确定性，而应该关注股票对各种正在改善的外部因素的弹性。所谓的改善，并不一定是指正增长，也可以是下降的速度放慢，或者下降的速度好于预期。 周期分析 有周期性就表明有可预测性。只有认识了四种周期的先后顺序和相互间的作用，才能在牛熊更替中作出有前瞻性和预见性的判断。 有杠杆，股价的波动幅度就常常会出人意料的剧烈，投资者往往因忽视了杠杆的力量而低估了股价的波动幅度，在牛市初期认为股价的上涨超出了基本面的支持。只有认识了杠杆的力量，才能认识到股价的波动和基本面的波动是不成正比的。 投资周期性股票，一定要在炮火声中买进，在烟花声中卖出。 当股市经过大跌达到合理的估值水平之后，开始在资金面和政策面的推动下上涨，这时不应该过多地担忧基本面（这就是华尔街常说的翻越忧虑之墙）。熊市见底时，基本面总是很不理想，呈现出所谓的黎明前的黑暗。 11.未来10年：投资路在何方 关键词：买入时机，保持独立性，消息与股份 最好的买入时机是卖家不得不在短期内快速清仓的时候。 市场悲观情绪弥漫或者乐观情绪泛滥时，若要保持独立性，最好是不和别人讨论，不看盘，不读当期卖方报告，关起门来读本老书、翻些旧报告，心里重温一下那句老话：人类的智慧如果压缩成一句话，就是“这很快将会过去”。 现在和10年前比最大的不同是什么？最大的不同就是中国经济的竞争力正在迅速削弱。 成本上升的主要原因有五个：劳动力成本的上升；环保成本的上升；土地成本的上升；资源和能源成本的上升以及人民币汇率的上升。 成本升高之后的“滞胀倾向”也可被称为中国经济的“新常态”。这个新常态就是成本更高，通胀压力更大，经济的内生潜力更低。 在2020年前，要想经济增长“保7”，基建和房地产投资是仅存的动力。而且，从人口红利和储蓄率的角度看，今后7~8年是中国提升基础设施的最后机会，之后将很难找到足够的基建工人和足够的低成本资金。 我们现在人均GDP是6 200美元，在成本上升的情况下克服中等收入国家陷阱，出路是什么？出路就是城镇化。城镇化首先能够延续城市的人口红利。通过农村土地的流转实现土地资本的货币化，人均资本就能够增加，剩下的农业土地集约化使用，留在农业的劳动力的人均土地就能增加。 中国能否跨越中等收入国家陷阱，关键就看能不能在今后5~10年执行好城镇化的战略，实现投资与消费的良性互动，促进城镇人口增长、人均资本增加和人均劳动生产率提高。 第一，从资产配置的角度来讲，股票比债券好。 第二，从商业模式上看，高利润的模式优于高周转模式，有定价权的公司会好于有成本优势的公司。 第三，从投资风格上看，价值股好于成长股。 成长股的现金流主要出现在几年以后，在高通胀的环境下，未来现金流的折现值大幅降低，成长股的估值应该更低才对。 12.对冲中国：机遇与挑战 关键词：选对公司，螳螂理论，估值与预期 全球最大对冲基金桥水资本创始人戴利奥认为：去杠杆的方式有3种：1.债务人通过节制消费来还债；2.债权人通过债务重组放弃部分债权或者延长还款期；3.定量宽松和印钞票。1和2会导致通货紧缩，3会导致通货膨胀，如果三者取得平衡，就不会有通胀通缩，且经济会温和复苏。 最一致的时候就是最危险的时候 原因有二：第一，越是一致，投资者对未来的集体预测区间就越小，而现实世界是千变万化的，区间越小，实际值落在区间外的概率就越大，所以越一致，错的概率越大。第二，一致预期已经体现在股价里了，即使是正确的时候，市场也不会给任何奖赏。而在一致预期错误的时候，市场会因为预期落空给予惩罚。 迈克尔·波特（Michael Porter）在《国家竞争优势》（The Competitive Advantage of Nations）中把国家竞争力发展分为四个阶段： 生产要素导向阶段（依靠资源或廉价劳力）； 投资导向阶段（大规模产能扩张，政府起主导作用）； 创新导向阶段（政府应无为而治）； 财富导向阶段（社会已富足，强调公平而非效率，社会价值挂帅，实用主义减弱）。 要想进入阶段3，必须让民企成为创新的主体。 伟大企业是竞争而不是补贴出来的。 投资心理学13.人性的弱点：投资者常见的心理误区 家花不如野花香 几乎每个国家（包括A股）低估值的价值股的长期投资回报率都显著优于高估值的成长股。原因很简单：投资者对未来的成长往往抱有不切实际的过高期望，而对于现有的价值却视而不见。 过度自信 仓位思维 锚固偏见 短期趋势长期化 把过去的增长过度外推到未来，把不可持续当作可持续，是成长股陷阱和周期股陷阱的共性。 亏损厌恶症 标题党 榔头症 美国消费股多，适合价值投资；加拿大资源股多，适合趋势投资。互联网赢家通吃，买龙头；休闲服装百花齐放，买成长。差异化产品，买品牌；同质化产品，买成本低的。 选择性记忆 选择性记忆是人脑自我保护的方式之一，也是提高投资水平的障碍。俾斯麦说，每个笨蛋都会从自己的教训中吸取经验，聪明人则会从别人的经验中获益。 差点就赢 羊群效应 心理账户 心理账户指的是人们喜欢在脑袋中把钱分成不同部分（例如买房的钱和买菜的钱）。投资者最常见的心理账户是把钱分为本钱和赚来的钱，并且对这两部分的钱体现出非常不同的风险偏好，这样无形中就把买入成本作为决策依据之一了。 14.后视镜15.傻瓜定价论聪明人（包括那些自作聪明的人）的悲剧在于，他们往往低估了傻瓜傻的程度。 市场持续非理性行为的时间可能长过你持续不破产的时间。 对市场敬畏但不屈服，逆市场而动但懂得自我保护。抄底时注意安全边际（不用杠杆也是其中之一），避开价值陷阱，远离反身性（会恶性循环、不能越跌越买），精挑细选低估值、高品质（特别是高端品牌或寡头垄断）的股票，然后分期分批加仓，确保判断错误时也不至于粉身碎骨。 16.这次不同了当人们在为“黄金十年”找论据时，市场离见顶就不远了；当人们在为长期的悲观寻找理由时，市场已经在底部区域了。投资者的悲哀，永远是轻易地放弃和错误地坚持。 17.树动风动心动短期来说，股价波动是人心与人心博弈的结果，是心在动，难以预测。中期来说，股价更多是由政策面决定：吹的是政策宽松的暖风，股价就上涨；刮的是政策紧缩的寒风，股价就下跌。所以说，中期是风在动。 长期来说，股价是由基本面决定的。 18.知易行难附录：投资访谈作为一位投资经理，要战胜市场、战胜同业，必须具备三个要素：一个是独立性，一个是前瞻性，一个是大局观。 投资的增长是消费增长的一个前提，这种关系决定了在城镇化和产业升级的过程中，投资依然会是拉动经济增长的主要动力之一。 -EOF-]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>读书笔记</tag>
        <tag>投资理财</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[世界上最简单的会计书-读书笔记]]></title>
    <url>%2F2018%2F01%2F27%2F%E4%B8%96%E7%95%8C%E4%B8%8A%E6%9C%80%E7%AE%80%E5%8D%95%E7%9A%84%E4%BC%9A%E8%AE%A1%E4%B9%A6-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[chapter 1 财务记账重要法则，左右必须相等。 资产=负债+所有者权益 存货是描述原材料、正在加工的在产品和准备出手的产成品的专业术语。所以，存货是一种资产。 毛利=销售收入-商品成本 ###chapter 2 净利润=毛利-费用 chapter 3 期末存货自动将变成期初存货。 如何将上周期末资产负债表转换费本周期初资产负债表？ 以前的盈利或是过去会计期间的利润称之为留存收益 应付票据因收到他人的借款而产生，而应付账款因为赊账购买原材料等物品而产生。应付票据需要支付利息。 chapter 4 产品制作的人工费被计入存货里面，直到产品出售后才被记为费用。 利息作为一项费用列示在利润表中。 待摊费用：预先支付的费用。当我们预付一笔费用时，他在未来的会计期间都具有价值。 权责发生制：在交易事项实际发生或产生时，用应计制进行会计核算。 在收付实现制下，你仅在交易事项发生时或涉及现金时才做会计核算 收付实现制可以延期缴纳税款 chapter 5 服务业：毛利=营收收入-服务成本 费用与所提供的咨询服务不直接相关 chapter 6 存货计价方法：先进先出法（FIFO）和 后进先出法（LIFO） 先进先出法下存货价值较低，期末存货价值较高，净利润较高 后进先出法可以用于节税，只适用于存货价值上升的情况，若存货价值不断下降则不能节税。 chapter 7 一般说来，价值大的采购支出使资产增加，从而被放入资产负债表中，即资本化。 资本化标准。该项支出使公司收益的时间；成本。 土地不能折旧 资产折旧法：直线折旧法，每年以固定比率折旧。此时资产实际价值可能并没有减少，折旧后价值称之为账面净值 折旧是一种非付现费用 chapter 8 盈利不是现金 一个企业的日常经营依靠的是现金 建筑物折旧的唯一方法直线折旧法，对于设备可以选择直线折旧法或者加速折旧法 chapter 9 资产负债表中项目罗列顺序的依据：根据资本其流动性的快慢。快的放在最上端。流动性是指变现速度 chapter10 使用比率消除数据的波动性。 成本销售收入比：成本总和/销售收入总和 费用销售收入比：费用总和/销售收入总和 净利率：利润/销售收入总和 -EOF-]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>读书笔记</tag>
        <tag>投资理财</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[euler002题]]></title>
    <url>%2F2018%2F01%2F25%2Feuler002%E9%A2%98%2F</url>
    <content type="text"><![CDATA[题目： Each new term in the Fibonacci sequence is generated by adding the previous two terms. By starting with 1 and 2, the first 10 terms will be: 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, … By considering the terms in the Fibonacci sequence whose values do not exceed four million, find the sum of the even-valued terms. 分析题目要的结果是找到斐波那契数列中不超过四百万的为偶数的项并求和。 首先就是要构造一个求第n项斐波那契数列的方法，这里我用递归实现的： 12345def fibonacci(n): if n==1 or n==0: return 1 else: return fibonacci(n-1)+fibonacci(n-2) 下面就是找出是偶数的项并且求和了，这里也有两种解法，第一种就是写个死循环，当斐波那契数列的项超过四百万就退出，判断能被2整除就加和，这种方法我没有实现=-=，因为比较耗时，懒得等。 第二种方法就是要观察数列的规律，为偶数的项的产生有没有规律。当然。。我都这么说了显然是有了。 1,1, 2, 3, 5, 8, 13, 21, 34, 55, 89,144.. 我们发现这些为偶数的项每隔两项就会出现（奇数偶数的性质决定的），这样我们循环的时候可以把步长加大，更迅速的求出结果。 123456789n=2sum=0while 1: res=fibonacci(n) if fibonacci(n)&gt;4000000: break sum = sum+res n+=3print sum -EOF-]]></content>
      <categories>
        <category>欧拉工程</category>
      </categories>
      <tags>
        <tag>euler</tag>
        <tag>math</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring源码之启动与初始化]]></title>
    <url>%2F2018%2F01%2F23%2FSpring%E6%BA%90%E7%A0%81%E4%B9%8BBean%E5%8A%A0%E8%BD%BD%2F</url>
    <content type="text"><![CDATA[此文源码基于Spring 4.3.2.RELEASE版本 转型Java开发快满一年了，工作中经常使用Spring，并享受着Spring带来的便利，未曾研究过他是如何工作的，临近年关，闲散时间慢慢多了，遂借鉴网上的资料以及自己的愚见啃一啃Spring的部分源码。 本文主要介绍Spring启动与初始化过程。 关于web.xml 首先看web.xml里面的配置。 12345678910&lt;!--上下文均省略--&gt; &lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt; classpath:/META-INF/spring/app-bootstrap.xml &lt;/param-value&gt; &lt;/context-param&gt; &lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt; &lt;/listener&gt; Spring是通过web.xml配置的org.springframework.web.context.ContextLoaderListener来初始化IoC容器的。ContextLoaderListener继承了ContextLoader，并且实现ServletContextListener接口。当Server容器（一般指tomcat）启动时，会收到事件初始化。web.xml文件中&lt;context-params&gt; 节点包含上下文类型(contextClass)和上下文配置路径(contextConfigLocation)两种配置参数。 其中，contextClass设置客户自定义的WebApplicationContext类型。当contextClass未找到时创建默认的XmlWebApplicationContext。 contextConfigLocation 用于设置applicatioContext*.xml文件的路径。不设置时默认为&quot;/WEB-INF/applicationContext.xml&quot; (详情见XmlWebApplicationContext 类)。多个上下文配置文件可用逗号或者空格分开。initWebApplicationContext方法 ContextLoaderListener 的构造方法 &lt;context-params&gt; 中的 contextClass 和 contextConfigLocation 这两个配置属性,调用初始化方法： contextInitialized() 创建Web应用程序上下文。下文将首先从应用上下文的初始化过程进行探究。 1234@Overridepublic void contextInitialized(ServletContextEvent event) &#123; initWebApplicationContext(event.getServletContext());&#125; initWebApplicationContext在ContextLoader类里面，代码贴到下面：12345678910111213141516171819202122232425262728293031323334353637383940public WebApplicationContext initWebApplicationContext(ServletContext servletContext) &#123; ... try &#123; // Store context in local instance variable, to guarantee that // it is available on ServletContext shutdown. if (this.context == null) &#123; this.context = createWebApplicationContext(servletContext); &#125; if (this.context instanceof ConfigurableWebApplicationContext) &#123; ConfigurableWebApplicationContext cwac = (ConfigurableWebApplicationContext) this.context; if (!cwac.isActive()) &#123; // The context has not yet been refreshed -&gt; provide services such as // setting the parent context, setting the application context id, etc if (cwac.getParent() == null) &#123; // The context instance was injected without an explicit parent -&gt; // determine parent for root web application context, if any. ApplicationContext parent = loadParentContext(servletContext); cwac.setParent(parent); &#125; configureAndRefreshWebApplicationContext(cwac, servletContext); &#125; &#125; servletContext.setAttribute(WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE, this.context); ClassLoader ccl = Thread.currentThread().getContextClassLoader(); if (ccl == ContextLoader.class.getClassLoader()) &#123; currentContext = this.context; &#125; else if (ccl != null) &#123; currentContextPerThread.put(ccl, this.context); &#125; if (logger.isDebugEnabled()) &#123; logger.debug("Published root WebApplicationContext as ServletContext attribute with name [" + WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE + "]"); &#125; if (logger.isInfoEnabled()) &#123; long elapsedTime = System.currentTimeMillis() - startTime; logger.info("Root WebApplicationContext: initialization completed in " + elapsedTime + " ms"); &#125; return this.context; &#125; ...&#125; 可以看到主要的逻辑都在try{}里。如果上下文为空的时候，则调用createWebApplicationContext方法创建上下文。 createWebApplicationContext方法123456789protected WebApplicationContext createWebApplicationContext(ServletContext sc) &#123; Class&lt;?&gt; contextClass = determineContextClass(sc); if (!ConfigurableWebApplicationContext.class.isAssignableFrom(contextClass)) &#123; throw new ApplicationContextException("Custom context class [" + contextClass.getName() + "] is not of type [" + ConfigurableWebApplicationContext.class.getName() + "]"); &#125; //根据类来返回实例 return (ConfigurableWebApplicationContext) BeanUtils.instantiateClass(contextClass);&#125; 其中determineContextClass就是来寻找WebApplicationContext接口的类： 123456789101112131415161718protected Class&lt;?&gt; determineContextClass(ServletContext servletContext) &#123; /**public static final String CONTEXT_CLASS_PARAM = "contextClass";**/ String contextClassName = servletContext.getInitParameter(CONTEXT_CLASS_PARAM); if (contextClassName != null) &#123; try &#123; return ClassUtils.forName(contextClassName, ClassUtils.getDefaultClassLoader()); &#125; ... &#125; else &#123; //关键代码 contextClassName = defaultStrategies.getProperty(WebApplicationContext.class.getName()); try &#123; return ClassUtils.forName(contextClassName, ContextLoader.class.getClassLoader()); &#125; ... &#125; &#125; 上述代码表明，如果开发者在web.xml中配置了一个参数名为contextClass，值为WebApplicationContext 接口实现类，那么getInitParameter就会返回这个配置的实现类；如果没有配置，defaultStrategies.getProperty()就返回默认的实现类XmlWebApplicationContext。默认实现类在ContextLoader静态代码段内，在类加载的时候就会执行。ContextLoader同路径下的可以找到这个配置文件 ContextLoader.properties 。 1org.springframework.web.context.WebApplicationContext=org.springframework.web.context.support.XmlWebApplicationContext XmlWebApplicationContext是WebApplicationContext这个接口的最终实现类，也是Spring启动时默认使用的类。 创建上下文的类型必须是ConfigurableWebApplicationContext的实例。 configureAndRefreshWebApplicationContext方法创建完WebApplicationContext之后就会调用configureAndRefreshWebApplicationContext() 来进行配置。 通常是对XmlWebApplicationContext进行初始化。 1234567891011121314protected void configureAndRefreshWebApplicationContext(ConfigurableWebApplicationContext wac, ServletContext sc) &#123; ... //在ServletContext中获取contextConfigLocation的值并咋找配置文件地址 wac.setServletContext(sc); //public static final String CONFIG_LOCATION_PARAM = "contextConfigLocation"; String configLocationParam = sc.getInitParameter(CONFIG_LOCATION_PARAM); if (configLocationParam != null) &#123; wac.setConfigLocation(configLocationParam); &#125; ... customizeContext(sc, wac); //刷新XmlWebApplicationContext wac.refresh();&#125; 拿到配置信息，就到了wac.refresh()方法了，此方法具体实现在AbstractApplicationContext类中： 12345678910111213141516171819202122232425262728293031public void refresh() throws BeansException, IllegalStateException &#123; synchronized (this.startupShutdownMonitor) &#123; // 容器预先准备，记录容器启动时间和标记 prepareRefresh(); // 创建Bean工厂，实现BeanDefinition的装载 ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory(); // 配置Bean工厂的上下文信息，如类装载器等 prepareBeanFactory(beanFactory); try &#123; // 在BeanDefinition被装载后，提供一个修改BeanFactory的入口 postProcessBeanFactory(beanFactory); // 在bean初始化之前，提供对BeanDefinition修改入口，PropertyPlaceholderConfigurer在这里被调用 invokeBeanFactoryPostProcessors(beanFactory); // 注册各种BeanPostProcessors，用于在bean被初始化时进行拦截，进行额外初始化操作 registerBeanPostProcessors(beanFactory); // /初始化MessageSource initMessageSource(); // 初始化上下文事件广播 initApplicationEventMulticaster(); // 模板方法 onRefresh(); // 注册监听器 registerListeners(); // 初始化所有未初始化的非懒加载的单例Bean finishBeanFactoryInitialization(beanFactory); // 发布时间通知 finishRefresh(); &#125; ... &#125;&#125; 这里就完成了IOC容器的初始化步骤了。 IOC初始化后IOC容器初始化之后可以看到还有一行代码： 1servletContext.setAttribute(WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE, this.context); 可以看到，初始化的context被存放在servletContext中，实际存放在了一个ConcurrentMap中。 到这里Spring的启动与初始化就结束了，整个Spring容器被放置在ServletContext这样一个类似于Map的结构中。ServletContext 从字面上理解也是Servlet的容器，被 Servlet 程序间接用来与外层 Web 容器通信，例如写日志，转发请求等。每一个 Web 应用程序含有一个Context ，被Web 应用内的各个程序共享。因为Context 可以用来保存资源并且共享，所以ServletContext 的常用场景是Web级应用缓存—- 把不经常更改的内容读入内存，所以服务器响应请求的时候就不需要进行慢速的磁盘I/O 了。 -EOF- 参考引用 漫谈Spring的启动与初始化（二） 看看Spring的源码（一）——Bean加载过程]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[euler001题]]></title>
    <url>%2F2018%2F01%2F20%2Feuler001%E9%A2%98%2F</url>
    <content type="text"><![CDATA[题目：If we list all the natural numbers below 10 that are multiples of 3 or 5, we get 3, 5, 6 and 9. The sum of these multiples is 23.Find the sum of all the multiples of 3 or 5 below 1000. 分析解法一题目很简单，将1000以内被3或5整除的数字加起来，所以最简单的解法就是暴力遍历：1print sum([x for x in range(1,1000) if x%3==0 or x%5==0]) 解法二当然，这个解法很简单，但不优雅，所以再用数学思维梳理一下刚才的题目，看看能不能总结出规律123456#3的倍数相加3+6+9+...+999=3*(1+2+3+...+333)#5的倍数相加5+10+15+...+995=5*(1+2+3+...+195)#1-n的累加公式1+2+3+...+n=(n*(n+1))/2 这样一写就简明多了，当让不要忘了在这两个数列里有3和5的公倍数被计算了两次，千万不要忘记减掉 1234def sumdivisibleby(n): p = 999/n return n*(p*(p+1))/2print sumdivisibleby(3)+sumdivisibleby(5)-sumdivisibleby(15) -EOF-]]></content>
      <categories>
        <category>欧拉工程</category>
      </categories>
      <tags>
        <tag>euler</tag>
        <tag>math</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F01%2F20%2FHello-World%2F</url>
    <content type="text"><![CDATA[Java版： 1234567public class HelloWorld &#123; public static void main(String[] args) &#123; System.out.println("Hello,World!"); &#125; &#125; c版： 1234#include &lt;stdio.h&gt;public void main()&#123; printf("Hello,World!")&#125; python版： 1print "Hello,World!" -EOF-]]></content>
      <tags>
        <tag>瞎写</tag>
      </tags>
  </entry>
</search>
